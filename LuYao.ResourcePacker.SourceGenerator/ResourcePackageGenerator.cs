using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace LuYao.ResourcePacker.SourceGenerator
{
    /// <summary>
    /// Source generator that creates strongly-typed resource access code for resource files.
    /// </summary>
    [Generator]
    public class ResourcePackageGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Get all additional files - MSBuild targets already filter by ResourcePackerPattern
            var resourceFiles = context.AdditionalTextsProvider.Collect();

            // Combine with compilation
            var compilationAndFiles = context.CompilationProvider.Combine(resourceFiles);

            // Register source output
            context.RegisterSourceOutput(compilationAndFiles, (spc, source) => Execute(spc, source.Left, source.Right));
        }

        private static void Execute(SourceProductionContext context, Compilation compilation, System.Collections.Immutable.ImmutableArray<AdditionalText> resourceFiles)
        {
            if (resourceFiles.Length == 0)
            {
                return; // No resource files, nothing to generate
            }

            // Get assembly name
            var assemblyName = compilation.AssemblyName ?? "Assembly";
            var className = $"{assemblyName}DataPackage";
            
            // Get root namespace from compilation options or default to assembly name
            var rootNamespace = GetRootNamespace(compilation);
            
            // Extract resource keys
            var resourceKeys = resourceFiles
                .Select(f => GetResourceKey(f.Path))
                .Where(k => !string.IsNullOrEmpty(k))
                .OrderBy(k => k)
                .Distinct()
                .ToList();

            // Generate source code
            var source = GenerateSourceCode(assemblyName, className, rootNamespace, resourceKeys);

            // Add source to compilation
            context.AddSource($"{className}.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private static string GetResourceKey(string filePath)
        {
            var fileName = Path.GetFileName(filePath);
            var firstDot = fileName.IndexOf('.');
            return firstDot > 0 ? fileName.Substring(0, firstDot) : fileName;
        }

        private static string GetRootNamespace(Compilation compilation)
        {
            // Try to get RootNamespace from compilation options
            // First, check if there's a global namespace option
            if (compilation.Options is CSharpCompilationOptions csharpOptions)
            {
                // Look for MSBuild properties that might contain the root namespace
                // The RootNamespace is typically passed through analyzer config
            }
            
            // Default to assembly name if no explicit root namespace is found
            return compilation.AssemblyName ?? "Assembly";
        }

        private static string GenerateSourceCode(string assemblyName, string className, string rootNamespace, List<string> resourceKeys)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine("using LuYao.ResourcePacker;");
            sb.AppendLine();
            
            // Add namespace
            sb.AppendLine($"namespace {rootNamespace}");
            sb.AppendLine("{");
            
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Provides strongly-typed access to resources in {assemblyName}.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");
            
            // Add resource key constants
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Resource keys available in this package.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static class Keys");
            sb.AppendLine("        {");
            
            foreach (var key in resourceKeys)
            {
                var safeKey = MakeSafeIdentifier(key);
                sb.AppendLine($"            /// <summary>Resource key for '{key}'</summary>");
                sb.AppendLine($"            public const string {safeKey} = \"{key}\";");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // Add lazy-initialized reader instance
            sb.AppendLine("        private static readonly Lazy<ResourcePackageReader> _reader = new Lazy<ResourcePackageReader>(() =>");
            sb.AppendLine("        {");
            sb.AppendLine($"            var datFilePath = Path.Combine(AppContext.BaseDirectory, \"{assemblyName}.dat\");");
            sb.AppendLine("            if (!File.Exists(datFilePath))");
            sb.AppendLine("            {");
            sb.AppendLine($"                throw new FileNotFoundException($\"Resource package file not found: {{datFilePath}}\");");
            sb.AppendLine("            }");
            sb.AppendLine("            return new ResourcePackageReader(datFilePath);");
            sb.AppendLine("        });");
            sb.AppendLine();
            
            sb.AppendLine("        /// <summary>");
            sb.AppendLine("        /// Gets the ResourcePackageReader instance for accessing resources.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        public static ResourcePackageReader Reader => _reader.Value;");
            sb.AppendLine();
            
            // Add helper methods for each resource
            foreach (var key in resourceKeys)
            {
                var safeKey = MakeSafeIdentifier(key);
                var methodName = $"Read{Capitalize(safeKey)}";
                var asyncMethodName = $"Read{Capitalize(safeKey)}Async";
                
                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Reads the '{key}' resource as a byte array asynchronously.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        public static System.Threading.Tasks.Task<byte[]> {asyncMethodName}()");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return Reader.ReadResourceAsync(Keys.{safeKey});");
                sb.AppendLine($"        }}");
                sb.AppendLine();
                
                sb.AppendLine($"        /// <summary>");
                sb.AppendLine($"        /// Reads the '{key}' resource as a string asynchronously.");
                sb.AppendLine($"        /// </summary>");
                sb.AppendLine($"        public static System.Threading.Tasks.Task<string> {asyncMethodName}AsString()");
                sb.AppendLine($"        {{");
                sb.AppendLine($"            return Reader.ReadResourceAsStringAsync(Keys.{safeKey});");
                sb.AppendLine($"        }}");
                sb.AppendLine();
            }
            
            sb.AppendLine("    }"); // Close class
            sb.AppendLine("}"); // Close namespace
            
            return sb.ToString();
        }

        private static string MakeSafeIdentifier(string name)
        {
            // Replace invalid characters with underscores
            var sb = new StringBuilder();
            for (int i = 0; i < name.Length; i++)
            {
                var c = name[i];
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    sb.Append(c);
                }
                else
                {
                    sb.Append('_');
                }
            }
            
            var result = sb.ToString();
            
            // Ensure it starts with a letter or underscore
            if (result.Length > 0 && !char.IsLetter(result[0]) && result[0] != '_')
            {
                result = "_" + result;
            }
            
            return result;
        }

        private static string Capitalize(string s)
        {
            if (string.IsNullOrEmpty(s))
                return s;
            
            return char.ToUpperInvariant(s[0]) + s.Substring(1);
        }
    }
}
