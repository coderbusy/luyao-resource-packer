# LuYao.ResourcePacker：优雅的 .NET 资源文件打包解决方案

## 项目简介

LuYao.ResourcePacker 是一个强大的 .NET 资源文件打包库，它能在构建时自动将多个资源文件打包成单一的 .dat 文件，并在运行时提供简洁的 API 访问这些资源。该项目支持 .NET Standard 2.0，具有良好的跨平台兼容性。

**最新版本**：0.1.1  
**项目地址**：https://github.com/coderbusy/luyao-resource-packer  
**NuGet 包**：https://www.nuget.org/packages/LuYao.ResourcePacker/

## 使用场景

LuYao.ResourcePacker 适用于以下多种场景：

### 1. 配置文件管理

在企业级应用中，经常需要管理大量的配置文件（JSON、XML、YAML 等）。使用 LuYao.ResourcePacker，可以将所有配置文件打包成一个文件，简化部署和分发。

```csharp
// 读取配置文件
string appConfig = await AppResourceAccess.ReadAppConfigAsyncAsString();
string dbConfig = await AppResourceAccess.ReadDbConfigAsyncAsString();
```

### 2. 模板引擎资源

Web 应用或代码生成工具中常需要使用模板文件（HTML、邮件模板、代码模板等）。将这些模板打包后，可以避免文件丢失，确保应用完整性。

```csharp
// 读取 HTML 模板
string emailTemplate = await TemplateResourceAccess.ReadEmailTemplateAsyncAsString();
string reportTemplate = await TemplateResourceAccess.ReadReportTemplateAsyncAsString();
```

### 3. 静态资源嵌入

对于需要嵌入静态资源（文本、图片数据、脚本等）的应用程序，传统方式是使用嵌入资源（Embedded Resources），但这种方式访问不够灵活。LuYao.ResourcePacker 提供了更简单的打包和访问方式。

### 4. 多语言资源文件

虽然 .NET 有自己的资源管理系统（.resx），但对于某些场景（如动态加载、自定义格式），LuYao.ResourcePacker 提供了更灵活的替代方案。

```csharp
// 读取不同语言的资源
string zhCN = await I18nResourceAccess.ReadZhCNAsyncAsString();
string enUS = await I18nResourceAccess.ReadEnUSAsyncAsString();
```

### 5. 游戏或多媒体应用资源

游戏开发或多媒体应用中需要管理大量的资源文件（关卡数据、对话文本、配置等），打包成单一文件可以提高加载效率和保护资源。

## 项目特性

- ✅ **构建时自动打包**：无需手动操作，构建时自动扫描并打包资源文件
- ✅ **MSBuild 集成**：完美集成到 .NET 构建流程中
- ✅ **简洁的运行时 API**：提供同步和异步两种访问方式
- ✅ **强类型访问**：通过 Source Generator 自动生成强类型访问代码，享受 IntelliSense 支持
- ✅ **可配置**：支持自定义文件模式、输出文件名等
- ✅ **跨平台**：基于 .NET Standard 2.0，支持 .NET Core、.NET Framework 等

## 使用方法

### 第一步：安装 NuGet 包

通过 NuGet 包管理器安装：

```bash
# .NET CLI
dotnet add package LuYao.ResourcePacker.MSBuild

# 包管理器控制台
Install-Package LuYao.ResourcePacker.MSBuild
```

或在 .csproj 文件中添加：

```xml
<PackageReference Include="LuYao.ResourcePacker.MSBuild" Version="0.1.1" />
```

> **注意**：`LuYao.ResourcePacker.MSBuild` 会自动引入核心库 `LuYao.ResourcePacker` 和源代码生成器 `LuYao.ResourcePacker.SourceGenerator`。

### 第二步：添加资源文件

在项目中创建资源文件，文件名需要包含 `.res.` 标识：

```
MyProject/
  ├── Resources/
  │   ├── config.res.json        # 配置文件
  │   ├── template.res.html      # HTML 模板
  │   ├── message.res.txt        # 文本消息
  │   └── data.res.xml           # XML 数据
  └── MyProject.csproj
```

**文件命名规则**：
- 必须包含 `.res.` 标识（如 `config.res.json`）
- `.res.` 前面的部分是资源的键名（如 `config`）
- `.res.` 后面的部分是文件扩展名（如 `.json`）

### 第三步：构建项目

执行构建命令：

```bash
dotnet build
```

构建完成后，会在输出目录生成 `<AssemblyName>.dat` 文件，所有 `.res.*` 文件都已打包其中。

### 第四步：访问资源

#### 方式一：使用强类型 API（推荐）

源代码生成器会自动创建一个静态类 `{AssemblyName}ResourceAccess`，提供强类型访问：

```csharp
using MyProject;  // 引入生成的类所在命名空间

// 使用常量访问资源键
Console.WriteLine(MyProjectResourceAccess.Keys.config);
Console.WriteLine(MyProjectResourceAccess.Keys.template);

// 读取资源为字符串
string config = await MyProjectResourceAccess.ReadConfigAsyncAsString();
string template = await MyProjectResourceAccess.ReadTemplateAsyncAsString();

// 读取资源为字节数组
byte[] data = await MyProjectResourceAccess.ReadDataAsync();
```

**强类型 API 的优势**：
- ✅ 编译时检查，避免拼写错误
- ✅ IntelliSense 支持，提高开发效率
- ✅ 重构友好，重命名资源文件时能自动更新代码
- ✅ 无需使用魔法字符串

#### 方式二：使用原始 API

如果需要更灵活的控制，可以直接使用 `ResourcePackageReader`：

```csharp
using LuYao.ResourcePacker;

// 创建读取器
using var reader = new ResourcePackageReader("MyProject.dat");

// 读取资源为字符串
string config = await reader.ReadResourceAsStringAsync("config");

// 读取资源为字节数组
byte[] data = await reader.ReadResourceAsync("template");

// 列出所有资源
foreach (var key in reader.ResourceKeys)
{
    Console.WriteLine($"Resource: {key}");
}
```

### 配置选项

在 .csproj 文件中可以自定义配置：

```xml
<PropertyGroup>
  <!-- 启用/禁用资源打包（默认：true） -->
  <ResourcePackerEnabled>true</ResourcePackerEnabled>
  
  <!-- 自定义文件匹配模式（默认：*.res.*） -->
  <ResourcePackerPattern>*.res.*</ResourcePackerPattern>
  
  <!-- 自定义输出文件名（默认：$(AssemblyName).dat） -->
  <ResourcePackerOutputFileName>$(AssemblyName).dat</ResourcePackerOutputFileName>
</PropertyGroup>
```

## 实现原理

LuYao.ResourcePacker 由三个核心组件组成：

### 1. LuYao.ResourcePacker（核心库）

核心库提供了两个主要类：

**ResourcePacker**：负责将多个资源文件打包成单一的 .dat 文件。

- 使用二进制格式存储资源
- 每个资源包含：资源键、数据长度、原始数据
- 支持任意类型的文件（文本、二进制等）

**ResourcePackageReader**：负责从 .dat 文件中读取资源。

- 使用内存映射文件（Memory-Mapped Files）技术，提高读取效率
- 支持按需加载，不会一次性加载所有资源到内存
- 线程安全设计，支持并发访问

**数据格式**：

```
.dat 文件结构：
[资源数量: 4 bytes]
[资源1键长度: 4 bytes][资源1键: N bytes][资源1数据长度: 4 bytes][资源1数据: N bytes]
[资源2键长度: 4 bytes][资源2键: N bytes][资源2数据长度: 4 bytes][资源2数据: N bytes]
...
```

### 2. LuYao.ResourcePacker.MSBuild（构建集成）

MSBuild 集成组件实现了自动化的资源打包流程：

**ResourcePackerTask**：自定义 MSBuild Task，在编译后执行资源打包。

```csharp
public class ResourcePackerTask : Task
{
    [Required]
    public string ProjectDir { get; set; }
    
    [Required]
    public string OutputPath { get; set; }
    
    public override bool Execute()
    {
        // 1. 扫描匹配模式的文件
        // 2. 调用 ResourcePacker 打包
        // 3. 输出 .dat 文件到输出目录
    }
}
```

**LuYao.ResourcePacker.MSBuild.props**：定义默认属性

```xml
<PropertyGroup>
  <ResourcePackerEnabled Condition="'$(ResourcePackerEnabled)' == ''">true</ResourcePackerEnabled>
  <ResourcePackerPattern Condition="'$(ResourcePackerPattern)' == ''">*.res.*</ResourcePackerPattern>
  <ResourcePackerOutputFileName Condition="'$(ResourcePackerOutputFileName)' == ''">$(AssemblyName).dat</ResourcePackerOutputFileName>
</PropertyGroup>
```

**LuYao.ResourcePacker.MSBuild.targets**：定义构建目标

```xml
<Target Name="PackResources" AfterTargets="AfterBuild" Condition="'$(ResourcePackerEnabled)' == 'true'">
  <ResourcePackerTask 
    ProjectDir="$(ProjectDir)" 
    OutputPath="$(OutputPath)"
    AssemblyName="$(AssemblyName)"
    ResourcePattern="$(ResourcePackerPattern)"
    OutputFileName="$(ResourcePackerOutputFileName)" />
</Target>
```

### 3. LuYao.ResourcePacker.SourceGenerator（源代码生成器）

源代码生成器是基于 Roslyn 的 C# Source Generator，在编译时自动生成强类型访问代码：

**工作流程**：

1. **监听编译过程**：通过 `IIncrementalGenerator` 接口监听编译
2. **读取 .dat 文件信息**：解析打包后的 .dat 文件，获取所有资源键
3. **生成代码**：为每个资源键生成对应的访问方法

**生成的代码示例**：

```csharp
namespace MyProject
{
    /// <summary>
    /// 自动生成的资源包访问类
    /// </summary>
    public static class MyProjectResourceAccess
    {
        private static readonly Lazy<ResourcePackageReader> _reader = 
            new Lazy<ResourcePackageReader>(() => 
                new ResourcePackageReader("MyProject.dat"));

        /// <summary>
        /// 资源包读取器
        /// </summary>
        public static ResourcePackageReader Reader => _reader.Value;

        /// <summary>
        /// 资源键常量
        /// </summary>
        public static class Keys
        {
            public const string config = "config";
            public const string template = "template";
            public const string message = "message";
        }

        /// <summary>
        /// 读取 config 资源（字节数组）
        /// </summary>
        public static Task<byte[]> ReadConfigAsync() => 
            Reader.ReadResourceAsync(Keys.config);

        /// <summary>
        /// 读取 config 资源（字符串）
        /// </summary>
        public static Task<string> ReadConfigAsyncAsString() => 
            Reader.ReadResourceAsStringAsync(Keys.config);

        // ... 为每个资源生成类似的方法
    }
}
```

## 技术亮点

### 1. 内存映射文件（Memory-Mapped Files）

使用 `MemoryMappedFile` 技术读取资源，避免将整个文件加载到内存：

```csharp
var mmf = MemoryMappedFile.CreateFromFile(
    filePath, 
    FileMode.Open, 
    null, 
    0, 
    MemoryMappedFileAccess.Read);
```

**优势**：
- 按需加载，节省内存
- 操作系统级别的缓存优化
- 支持大文件处理

### 2. 线程安全设计

`ResourcePackageReader` 使用 `ReaderWriterLockSlim` 实现线程安全：

```csharp
private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();

public async Task<byte[]> ReadResourceAsync(string key)
{
    _lock.EnterReadLock();
    try
    {
        // 读取操作
    }
    finally
    {
        _lock.ExitReadLock();
    }
}
```

### 3. Source Generator 增量编译

使用 `IIncrementalGenerator` 而非旧版的 `ISourceGenerator`，支持增量编译：

```csharp
[Generator]
public class ResourcePackageGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 只在 .dat 文件变化时重新生成代码
        var datFiles = context.AdditionalTextsProvider
            .Where(text => text.Path.EndsWith(".dat"));
        
        context.RegisterSourceOutput(datFiles, GenerateSource);
    }
}
```

## 注意事项

### 1. 文件命名规范

- **必须**包含 `.res.` 标识，例如 `config.res.json`
- `.res.` 前面的部分作为资源键（不含扩展名）
- 资源键不区分大小写（在某些文件系统上）
- 避免使用特殊字符和空格

### 2. 构建配置

- 确保 `ResourcePackerEnabled` 属性为 `true`（默认即为 true）
- 如果资源文件较多，构建时间可能会略微增加
- `.dat` 文件会自动复制到输出目录，不要手动删除

### 3. 部署注意事项

- 部署时必须包含生成的 `.dat` 文件
- `.dat` 文件必须与程序集位于同一目录
- 如果使用自定义输出文件名，确保运行时路径正确

### 4. 性能考虑

- 资源文件会在首次访问时被缓存，后续访问更快
- 对于超大文件（>100MB），建议评估是否适合打包
- 并发读取是安全的，但大量并发可能影响性能

### 5. 版本兼容性

- 支持 .NET Standard 2.0+、.NET Core 2.0+、.NET Framework 4.6.1+
- 源代码生成器需要支持 C# 9.0+ 的编译器
- 如果升级库版本，建议清理并重新构建项目

### 6. 调试技巧

- 如果资源未打包，检查文件名是否包含 `.res.`
- 查看构建输出，确认 `PackResources` 任务已执行
- 可以手动检查 `.dat` 文件是否存在于输出目录
- 使用 `ResourcePackageReader.ResourceKeys` 列出所有已打包的资源

### 7. 与嵌入资源的对比

| 特性 | LuYao.ResourcePacker | 嵌入资源（Embedded Resources） |
|------|---------------------|------------------------------|
| 构建方式 | 打包成 .dat 文件 | 嵌入到程序集 |
| 访问方式 | 简洁的 API | 需要使用 Assembly.GetManifestResourceStream |
| 文件分发 | 需要单独的 .dat 文件 | 无需额外文件 |
| 更新资源 | 可以单独替换 .dat 文件 | 必须重新编译程序集 |
| 灵活性 | 高 | 低 |
| 强类型支持 | 有（Source Generator） | 无 |

### 8. 安全性考虑

- `.dat` 文件是明文存储（未加密）
- 如果需要保护敏感资源，请在打包前加密或使用其他安全机制
- 不建议在 .dat 文件中存储密码、密钥等敏感信息

## 实际应用案例

### 案例 1：API 文档生成器

某 API 文档生成工具使用 LuYao.ResourcePacker 打包 Markdown 模板和样式文件：

```csharp
// 读取文档模板
var apiTemplate = await DocGenResourceAccess.ReadApiTemplateAsyncAsString();
var indexTemplate = await DocGenResourceAccess.ReadIndexTemplateAsyncAsString();

// 生成文档
var doc = templateEngine.Render(apiTemplate, apiData);
```

### 案例 2：配置管理系统

企业级应用使用 LuYao.ResourcePacker 管理多环境配置：

```csharp
// Resources/
//   ├── dev.res.json
//   ├── staging.res.json
//   └── prod.res.json

var env = Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT");
var configJson = env switch
{
    "Development" => await AppResourceAccess.ReadDevAsyncAsString(),
    "Staging" => await AppResourceAccess.ReadStagingAsyncAsString(),
    "Production" => await AppResourceAccess.ReadProdAsyncAsString(),
    _ => throw new Exception("Unknown environment")
};
```

### 案例 3：游戏关卡数据

独立游戏使用 LuYao.ResourcePacker 打包关卡配置：

```csharp
// Resources/
//   ├── level1.res.json
//   ├── level2.res.json
//   └── level3.res.json

var levelData = await GameResourceAccess.ReadLevel1AsyncAsString();
var level = JsonSerializer.Deserialize<Level>(levelData);
```

## 路线图

未来计划的功能：

- [ ] 支持资源压缩（Gzip、Brotli）
- [ ] 支持资源加密
- [ ] 提供资源打包 CLI 工具
- [ ] 支持热重载（在开发模式下）
- [ ] 性能监控和诊断工具
- [ ] 支持更多资源格式的优化

## 贡献指南

欢迎贡献代码、报告问题或提出建议！

- 提交 Issue：https://github.com/coderbusy/luyao-resource-packer/issues
- 提交 Pull Request：https://github.com/coderbusy/luyao-resource-packer/pulls

## 许可证

本项目采用 MIT 许可证，详见 [LICENSE](LICENSE) 文件。

## 作者

Created by Soar360 on 2025-10-25

---

**相关链接**：

- GitHub 仓库：https://github.com/coderbusy/luyao-resource-packer
- NuGet 包：https://www.nuget.org/packages/LuYao.ResourcePacker/
- 问题反馈：https://github.com/coderbusy/luyao-resource-packer/issues

感谢使用 LuYao.ResourcePacker！如果觉得有用，请给项目一个 ⭐️！
